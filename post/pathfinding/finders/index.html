<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"><head><link href="http://gmpg.org/xfn/11" rel="profile"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"><link href="https://arianv.com/post/pathfinding/finders/" rel="canonical"><title>Finders</title><link href='//fonts.googleapis.com/css?family=Fjalla+One|Open+Sans:300' rel='stylesheet' type='text/css'><link rel="stylesheet" href="//arianv.com//css/main.css"> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="//arianv.com/apple-touch-icon-144-precomposed.png"><link href="//arianv.com/favicon.png" rel="icon"><link href="" rel="alternate" type="application/rss+xml" title="Arian&#39;s Portfolio &middot; "/><meta name="description" content=""><meta name="keywords" content=""> <meta property="og:title" content="Finders" />
<meta property="og:description" content="Finders&#182;In this particular project, we are required to implement three search algorithms:
 BFS DFS A*  BFS&#182;BFS or breadth-first search traverses the graph by exploring all the neighbors of the root of the graph first, and then proceeds to the next depth of the graph until the end is found.
Implementing this is simple enough - let us keep a queue, add neighbors to it, and iterate on the queue until we find our target." />
<meta property="og:type" content="article" />
<meta property="og:url" content="//arianv.com/post/pathfinding/finders/" />
<meta property="article:published_time" content="2019-03-17T13:16:26&#43;08:00"/>
<meta property="article:modified_time" content="2019-03-17T13:16:26&#43;08:00"/>

  
<meta itemprop="name" content="Finders">
<meta itemprop="description" content="Finders&#182;In this particular project, we are required to implement three search algorithms:
 BFS DFS A*  BFS&#182;BFS or breadth-first search traverses the graph by exploring all the neighbors of the root of the graph first, and then proceeds to the next depth of the graph until the end is found.
Implementing this is simple enough - let us keep a queue, add neighbors to it, and iterate on the queue until we find our target.">


<meta itemprop="datePublished" content="2019-03-17T13:16:26&#43;08:00" />
<meta itemprop="dateModified" content="2019-03-17T13:16:26&#43;08:00" />
<meta itemprop="wordCount" content="907">



<meta itemprop="keywords" content="Python,Algorithms," />
 <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Finders"/>
<meta name="twitter:description" content="Finders&#182;In this particular project, we are required to implement three search algorithms:
 BFS DFS A*  BFS&#182;BFS or breadth-first search traverses the graph by exploring all the neighbors of the root of the graph first, and then proceeds to the next depth of the graph until the end is found.
Implementing this is simple enough - let us keep a queue, add neighbors to it, and iterate on the queue until we find our target."/>
 <meta name="twitter:label1" value="Reading time"><meta name="twitter:data1" value="5 min read">  </head><body><div class="content container"> <nav class="main-nav"><div class="ribbon-content"><div class="nav-inner"><ul><li> <a id="nav-home" data-page="home" href="//arianv.com/">Home</a></li><li> <a id="nav-articles" data-page="articles" href="//arianv.com/post">Articles</a></li><li> <a id="nav-articles" data-page="ludum-dare" href="//arianv.com/ludum-dare">Ludum Dare</a></li></ul></div></div></nav><div class="post pathfinding-180"><div class="post-info"> <span class="post-date">Mar 17, 2019  &middot; <a href="//arianv.com/post/pathfinding/finders/#disqus_thread">Comments</a></span>   <span class="post-tags"><a class="label" href="//arianv.com//tags/python">Python</a><a class="label" href="//arianv.com//tags/algorithms">Algorithms</a></span> </div><article> 
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Finders">Finders<a class="anchor-link" href="#Finders">&#182;</a></h1><p>In this particular project, we are required to implement three search algorithms:</p>
<ul>
<li>BFS</li>
<li>DFS</li>
<li>A*</li>
</ul>
<h2 id="BFS">BFS<a class="anchor-link" href="#BFS">&#182;</a></h2><p>BFS or breadth-first search traverses the graph by exploring all the neighbors of the root of the graph first, and then proceeds to the next depth of the graph until the end is found.</p>
<p>Implementing this is simple enough - let us keep a queue, add neighbors to it, and iterate on the queue until we find our target. Notice how our implementation accepts <strong>arbitrary</strong> data structures for the grid/graph by allowing input of a <code>get_neighbor</code> function.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">get_adjacent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">queue</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">get_adjacent</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                <span class="c1"># found!</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Notice that in our breadth first search, we want to know the path traversed by our algorithm to get to the end. There's a couple of methods to achieve this, but to keep the data structures as simple and pure as possible, I opted to implement a backtrace.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">end</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">start</span><span class="p">:</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">path</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">path</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">get_adjacent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">queue</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">{}</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">get_adjacent</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">with_expansion</span><span class="p">:</span> <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">expansion</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">path</span><span class="p">,</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can also make our algorithm return the list of expanded nodes. This will help us later if we want to see what 'path' the algorithm took to generate the solution.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">get_adjacent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">with_expansion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">queue</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">with_expansion</span><span class="p">:</span>
        <span class="n">expansion</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_expansion</span><span class="p">:</span>
            <span class="n">expansion</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">get_adjacent</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">with_expansion</span><span class="p">:</span> <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">expansion</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">path</span><span class="p">,</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="DFS">DFS<a class="anchor-link" href="#DFS">&#182;</a></h2><p>DFS or depth-first search traverses the graph by exploring to the end of each branch first.</p>
<p>Implementing this takes even less lines of code - we simply keep a stack, and add neighbors of the node there:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">get_adjacent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">with_expansion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">stack</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="p">[</span><span class="n">start</span><span class="p">])],</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">curr</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">curr</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">with_expansion</span><span class="p">:</span> <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">visited</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">path</span><span class="p">,</span>
        <span class="k">if</span> <span class="n">curr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">get_adjacent</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">neighbor</span><span class="p">]))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that I took the liberty of implementing it with the <code>path</code> and <code>expansion path</code> taken into account.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="A*">A*<a class="anchor-link" href="#A*">&#182;</a></h2><p>A<em> is perhaps the most interesting search-algorithm here, being the only informed search algorithm. In A</em>, we make use of a <code>heuristic</code> function that will guide the search.</p>
<p>It is a bit longer than the two previous algorithms, but not that much longer.</p>
<p>The first thing that is different is that we need two new arguments, <code>cost</code> and <code>heuristic</code>. <code>cost</code> will return the cost to traverse between two nodes, while <code>heuristic</code> will serve as the heuristic function for our algorithm. This makes our algorithm more general by supporting different problem spaces.</p>
<p>We also add the data structures that we need - in particular, a queue (a priority queue), a set for visited nodes, a map for parents (for backtracking) and a map for <code>G</code> and <code>F</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[15]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">astar</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">get_adjacent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">heuristic</span><span class="p">,</span> <span class="n">with_expansion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">queue</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start</span><span class="p">]),</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">{}</span>
    <span class="n">g_cost</span><span class="p">,</span> <span class="n">f_cost</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>

    <span class="n">g_cost</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">f_cost</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">heuristic</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We then take the item in the queue with the lowest cost for <code>F</code></p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[18]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">astar_cut</span><span class="p">():</span> <span class="c1"># not really a function, we just define it as such so jupyter won&#39;t run it</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">curr_score</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># TODO: Turn this into a priority queue?</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">f_cost</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">curr_score</span><span class="p">:</span>
                <span class="n">curr_score</span> <span class="o">=</span> <span class="n">f_cost</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">coord</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>After that, we check if it is the goal. If not, we remove it from the queue and iterate over its neighbors, updating the <code>parent map</code>, <code>f_cost</code>, and <code>g_cost</code> in the process:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">astar_cut</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">get_adjacent</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">g_cost</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">+</span> <span class="n">manhattan_distance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">g</span> <span class="o">&gt;=</span> <span class="n">g_cost</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span>
        <span class="n">g_cost</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">f_cost</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span> <span class="o">+</span> <span class="n">heuristic</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This is the whole algorithm defined:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[16]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">astar</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">get_adjacent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">heuristic</span><span class="p">,</span> <span class="n">with_expansion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">queue</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start</span><span class="p">]),</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">{}</span>
    <span class="n">g_cost</span><span class="p">,</span> <span class="n">f_cost</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>

    <span class="n">g_cost</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">f_cost</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">heuristic</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">with_expansion</span><span class="p">:</span>
        <span class="n">expansion</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">curr_score</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># TODO: Turn this into a priority queue?</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">f_cost</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">curr_score</span><span class="p">:</span>
                <span class="n">curr_score</span> <span class="o">=</span> <span class="n">f_cost</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">coord</span>

        <span class="k">if</span> <span class="n">curr</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">with_expansion</span><span class="p">:</span> <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">expansion</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">path</span><span class="p">,</span>

        <span class="n">queue</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">curr</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">with_expansion</span><span class="p">:</span>
            <span class="n">expansion</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">get_adjacent</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">g</span> <span class="o">=</span> <span class="n">g_cost</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">+</span> <span class="n">manhattan_distance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">g</span> <span class="o">&gt;=</span> <span class="n">g_cost</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="n">g_cost</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
            <span class="n">f_cost</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span> <span class="o">+</span> <span class="n">heuristic</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With our generic algorithms defined, we can move on to see how we can use it to <a href="../grid-search">search in our grid</a>.</p>

</div>
</div>
</div>
 

  <hr/><div class="post-series-desc"><p>This is a post in the <a href="//arianv.com//series/cs-180-pathfinding" id="series"><b>CS 180 Pathfinding</b></a> series.<br/> Other posts in this series:</p>  <ul class="series"> <li>Mar 17, 2019 - <a href="//arianv.com/post/cs-180-pathfinding/">CS 180 Pathfinding</a></li> <li>Mar 17, 2019 - <a href="//arianv.com/post/pathfinding/grid/">Grid</a></li> <li>Mar 17, 2019 - <a href="//arianv.com/post/pathfinding/finders/">Finders</a></li> <li>Mar 17, 2019 - <a href="//arianv.com/post/pathfinding/grid-search/">Grid Search</a></li> <li>Mar 17, 2019 - <a href="//arianv.com/post/pathfinding/test-cases/">Test Cases</a></li> <li>Mar 17, 2019 - <a href="//arianv.com/post/pathfinding/running-test-cases/">Running Test Cases</a></li> <li>Mar 17, 2019 - <a href="//arianv.com/post/pathfinding/timing/">Timing</a></li> <li>Mar 17, 2019 - <a href="//arianv.com/post/pathfinding/viz/">Viz</a></li> </ul></div> </article> <footer class="article-footer"><h3>Arian Valdez <a href="//twitter.com/Secretmapper">@Secretmapper</a></h3><p>React.JS and Node.JS Software engineering consultant. Developer/Designer Hybrid. Author of Alt Tracker, Combustion, Riyu, etc.</p></footer> <div id="disqus_thread"></div></div></div> <div id="disqus_thread"></div><script>
  
  var disqus_config = function () {
    
      this.page.identifier = 'Finders';
    
    this.page.title = "Finders";
    this.page.url = "https://arianv.com/post/pathfinding/finders/";
  };
  (function() {  
    var d = document, s = d.createElement('script');
    s.src = 'https://arianv.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>  </div><footer class="page-footer">Copyright &#169; Arian Allenson M. Valdez | CC-BY-SA</footer><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/solarized-dark.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script> <script id="dsq-count-scr" src="//arianv.disqus.com/count.js" async></script>  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', "UA-60507502-1", 'auto');
  ga('send', 'pageview');
</script> </body></html>
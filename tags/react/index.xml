<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React on Arian&#39;s Portfolio</title>
    <link>//arianv.com/tags/react/</link>
    <description>Recent content in React on Arian&#39;s Portfolio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Aug 2017 10:25:27 +0800</lastBuildDate>
    
	<atom:link href="//arianv.com/tags/react/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The 4R framework - 3 libraries to use in your React app</title>
      <link>//arianv.com/post/the-4r-framework-3-libraries-to-use-in-your-react-app/</link>
      <pubDate>Thu, 24 Aug 2017 10:25:27 +0800</pubDate>
      
      <guid>//arianv.com/post/the-4r-framework-3-libraries-to-use-in-your-react-app/</guid>
      <description>React fits well right in to the Unix philosophy - it does one thing, and one thing well. It&amp;rsquo;s a beautifully designed, declarative library for building user interfaces.
To write complex React applications however, it would be best to use more libraries than just React in it&amp;rsquo;s lonesome.
The vast and rapidly evolving javascript landscape means there&amp;rsquo;s almost always a library that we can leverage for any given task. Given that, there are 3 libraries I consider essential when making React apps, and I&amp;rsquo;ve consolidated it to this one catchy name because marketing is everything</description>
    </item>
    
    <item>
      <title>Use Default HOCs for Component Logic</title>
      <link>//arianv.com/post/use-default-hocs-for-component-logic/</link>
      <pubDate>Wed, 23 Aug 2017 12:04:32 +0800</pubDate>
      
      <guid>//arianv.com/post/use-default-hocs-for-component-logic/</guid>
      <description>Perhaps one of the most useful patterns for writing React applications is the classic &amp;ldquo;Container and Presentational Components&amp;rdquo; pattern. Even without knowledge of React, it makes sense - it decomposes concerns between component presentation and logic.
One very useful pattern I&amp;rsquo;ve used to achieve this is by using Higher Order Components to inject default logic to components. This pattern drastically reduces component API boilerplate and more effectively separates implementation and presentational concerns of components.</description>
    </item>
    
    <item>
      <title>Module Bundling and Webpack in Simple Terms</title>
      <link>//arianv.com/post/module-bundling-and-webpack-in-simple-terms/</link>
      <pubDate>Thu, 29 Dec 2016 21:22:19 +0800</pubDate>
      
      <guid>//arianv.com/post/module-bundling-and-webpack-in-simple-terms/</guid>
      <description>#chapter-1, #chapter-2__scroll { display: none; position: relative; height: 100vh; width: 100%; } .chapter-1__heading { font-size: 2rem; margin-bottom: 0; margin-top: 0; max-width: none !important; position: absolute; text-align: center; width: 100%; } .chapter-1__heading-1 { opacity: 1; } .chapter-1__hider-1, .chapter-1__hider-2, .chapter-1__hider-3, .chapter-1__hider-4 { background-color: #002B36; height: 1rem; position: absolute; width: 100%; } .chapter-2__darkener { background-color: gray; opacity: 0.5; position: absolute; height: 30rem; width: 100%; } .chapter-2__code-file { position: absolute; width: 100%; } .</description>
    </item>
    
  </channel>
</rss>